#include "DebugIcosphere.h"

namespace sess
{

// What, you DON'T have the vertices for a simple icosphere memorized?
float verts[] = 
{
	0, 0, -1,							0.7236, -0.52572, -0.447215,
	-0.276385, -0.85064, -0.447215,		0.7236, -0.52572, -0.447215,
	0, 0, -1,							0.7236, 0.52572, -0.447215,
	0, 0, -1,							-0.276385, -0.85064, -0.447215,
	-0.894425, 0, -0.447215,			0, 0, -1,
	-0.894425, 0, -0.447215,			-0.276385, 0.85064, -0.447215,
	0, 0, -1,							-0.276385, 0.85064, -0.447215,
	0.7236, 0.52572, -0.447215,			0.7236, -0.52572, -0.447215,
	0.7236, 0.52572, -0.447215,			0.894425, 0, 0.447215,
	-0.276385, -0.85064, -0.447215,		0.7236, -0.52572, -0.447215,
	0.276385, -0.85064, 0.447215,		-0.894425, 0, -0.447215,
	-0.276385, -0.85064, -0.447215,		-0.7236, -0.52572, 0.447215,
	-0.276385, 0.85064, -0.447215,		-0.894425, 0, -0.447215,
	-0.7236, 0.52572, 0.447215,			0.7236, 0.52572, -0.447215,
	-0.276385, 0.85064, -0.447215,		0.276385, 0.85064, 0.447215,
	0.7236, -0.52572, -0.447215,		0.894425, 0, 0.447215,
	0.276385, -0.85064, 0.447215,		-0.276385, -0.85064, -0.447215,
	0.276385, -0.85064, 0.447215,		-0.7236, -0.52572, 0.447215,
	-0.894425, 0, -0.447215,			-0.7236, -0.52572, 0.447215,
	-0.7236, 0.52572, 0.447215,			-0.276385, 0.85064, -0.447215,
	-0.7236, 0.52572, 0.447215,			0.276385, 0.85064, 0.447215,
	0.7236, 0.52572, -0.447215,			0.276385, 0.85064, 0.447215,
	0.894425, 0, 0.447215,				0.276385, -0.85064, 0.447215,
	0.894425, 0, 0.447215,				0, 0, 1,
	-0.7236, -0.52572, 0.447215,		0.276385, -0.85064, 0.447215,
	0, 0, 1,							-0.7236, 0.52572, 0.447215,
	-0.7236, -0.52572, 0.447215,		0, 0, 1,
	0.276385, 0.85064, 0.447215,		-0.7236, 0.52572, 0.447215,
	0, 0, 1,							0.894425, 0, 0.447215,
	0.276385, 0.85064, 0.447215,		0, 0, 1
};

float normals[] =
{
	0.187597, -0.577354, -0.794651,		0.187597, -0.577354, -0.794651,
	0.187597, -0.577354, -0.794651,		0.607065, 0, -0.794652,
	0.607065, 0, -0.794652,				0.607065, 0, -0.794652,
	-0.491122, -0.356829, -0.794652,	-0.491122, -0.356829, -0.794652,
	-0.491122, -0.356829, -0.794652,	-0.491122, 0.356829, -0.794652,
	-0.491122, 0.356829, -0.794652,		-0.491122, 0.356829, -0.794652,
	0.187597, 0.577354, -0.794651,		0.187597, 0.577354, -0.794651,
	0.187597, 0.577354, -0.794651,		0.982246, 0, -0.187597,
	0.982246, 0, -0.187597,				0.982246, 0, -0.187597,
	0.303536, -0.934171, -0.187589,		0.303536, -0.934171, -0.187589,
	0.303536, -0.934171, -0.187589,		-0.794649, -0.577359, -0.187587,
	-0.794649, -0.577359, -0.187587,	-0.794649, -0.577359, -0.187587,
	-0.794649, 0.577359, -0.187587,		-0.794649, 0.577359, -0.187587,
	-0.794649, 0.577359, -0.187587,		0.303536, 0.934171, -0.187589,
	0.303536, 0.934171, -0.187589,		0.303536, 0.934171, -0.187589,
	0.794649, -0.577359, 0.187587,		0.794649, -0.577359, 0.187587,
	0.794649, -0.577359, 0.187587,		-0.303536, -0.934171, 0.187589,
	-0.303536, -0.934171, 0.187589,		-0.303536, -0.934171, 0.187589,
	-0.982246, 0, 0.187597,				-0.982246, 0, 0.187597,
	-0.982246, 0, 0.187597,				-0.303536, 0.934171, 0.187589,
	-0.303536, 0.934171, 0.187589,		-0.303536, 0.934171, 0.187589,
	0.794649, 0.577359, 0.187587,		0.794649, 0.577359, 0.187587,
	0.794649, 0.577359, 0.187587,		0.491122, -0.356829, 0.794652,
	0.491122, -0.356829, 0.794652,		0.491122, -0.356829, 0.794652,
	-0.187596, -0.577354, 0.794651,		-0.187596, -0.577354, 0.794651,
	-0.187596, -0.577354, 0.794651,		-0.607065, 0, 0.794652,
	-0.607065, 0, 0.794652,				-0.607065, 0, 0.794652,
	-0.187597, 0.577354, 0.794651,		-0.187597, 0.577354, 0.794651,
	-0.187597, 0.577354, 0.794651,		0.491122, 0.356829, 0.794652,
	0.491122, 0.356829, 0.794652,		0.491122, 0.356829, 0.794652
};

std::uint32_t g_indices[] =
{
	0,1,2,		3,4,5,		6,7,8,
	9,10,11,	12,13,14,	15,16,17,
	18,19,20,	21,22,23,	24,25,26,
	27,28,29,	30,31,32,	33,34,35,
	36,37,38,	39,40,41,	42,43,44,
	45,46,47,	48,49,50,	51,52,53,
	54,55,56,	57,58,59
};

DebugMaterialIcosphere::DebugMaterialIcosphere
(
	ComPtr<ID3D11Device> device,
	MaterialOnlyShader::Material mat,
	const Vec3& position,
	const Vec3& scale,
	float rotationSpeed
)
	: call_(nullptr)
	, material_(mat)
	, rotationSpeed_(rotationSpeed)
	, rotationAngle_(0.f)
	, modelTransform_(position, Quaternion::Identity, scale)
{
	std::vector<MaterialOnlyShader::Vertex> vertices;
	vertices.reserve(_countof(verts));
	for (std::uint32_t idx = 0u; idx < _countof(verts); idx += 3)
	{
		vertices.push_back
		(
			MaterialOnlyShader::Vertex
			(
				Vec3(verts[idx], verts[idx + 1u], verts[idx + 2u]),
				Vec3(normals[idx], normals[idx + 1u], normals[idx + 2u])
			)
		);
	}

	std::vector<std::uint32_t> indices;
	indices.reserve(_countof(g_indices));
	for (std::uint32_t idx = 0u; idx < _countof(g_indices); idx++)
	{
		indices.push_back(g_indices[idx]);
	}

	call_ = std::make_shared<MaterialOnlyShader::RenderCall>(device, vertices, indices);
}

bool DebugMaterialIcosphere::Update(float dt)
{
	rotationAngle_ += rotationSpeed_ * dt / 1000.f;
	while (rotationAngle_ > 2.f * PI)
	{
		rotationAngle_ -= 2.f * PI;
	}

	modelTransform_.Rotation = Quaternion(Vec3::UnitY, rotationAngle_);

	return true;
}

bool DebugMaterialIcosphere::Render(ComPtr<ID3D11DeviceContext> context, MaterialOnlyShader* shader) const
{
	shader->SetObjectMaterial(material_);
	shader->SetModelTransform(modelTransform_.GetTransformMatrix());
	shader->Render(context, *call_);

	return true;
}

}